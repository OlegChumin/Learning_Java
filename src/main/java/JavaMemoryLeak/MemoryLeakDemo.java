package JavaMemoryLeak;

import java.util.ArrayList;
import java.util.List;

/**
 * Утечка памяти происходит, когда объекты в памяти больше не нужны, но сборщик мусора не может их удалить из-за
 * наличия ссылок на них. В Java утечки памяти могут возникать по разным причинам, включая неправильное использование
 * коллекций, статических полей или слушателей событий.
 * <p>
 * Вот пример кода на Java, демонстрирующий утечку памяти:
 */

public class MemoryLeakDemo {
    private static class LeakingObject {
        private byte[] largeArray = new byte[1024 * 1024]; // 1Mbt
    }

    private static List<LeakingObject> leakingObjects = new ArrayList<>();

    public static void main(String[] args) throws InterruptedException {
        while (true) {
            leakingObjects.add(new LeakingObject());
            System.out.println("Leaking object count: " + leakingObjects.size());
//            Thread.sleep(100); // Sleep for 0.1 second before creating the next object
        }
    }
}

/**
 * В этом примере мы создаем класс LeakingObject, который содержит массив байтов largeArray размером 1 МБ. В методе main
 * есть бесконечный цикл, который каждую секунду создает новый объект LeakingObject и добавляет его в список
 * leakingObjects. Поскольку список является статическим полем класса, ссылки на объекты LeakingObject не теряются,
 * и сборщик мусора не может их удалить. Это приводит к постоянному увеличению использования памяти, что в конечном
 * итоге может вызвать исключение OutOfMemoryError.
 * <p>
 * Чтобы избежать утечки памяти, необходимо обеспечить правильное удаление ссылок на объекты, когда они больше не нужны,
 * и использовать слабые ссылки (WeakReference), если это возможно, для объектов, которые могут быть удалены сборщиком
 * мусора при необходимости.
 * <p>
 * Статический внутренний класс (или статический вложенный класс) используется для создания логической связи между
 * внешним и внутренним классами, когда создание объекта внутреннего класса не зависит от создания объекта внешнего класса.
 * <p>
 * Статический внутренний класс имеет следующие особенности и преимущества:
 * <p>
 * Независимость от внешнего класса: Статический внутренний класс не имеет ссылки на объект внешнего класса, что делает
 * его более независимым. Объекты статического внутреннего класса могут быть созданы без создания объекта внешнего
 * класса.
 * <p>
 * Улучшение инкапсуляции: Статический внутренний класс может иметь доступ к приватным статическим членам внешнего
 * класса, что обеспечивает улучшенную инкапсуляцию кода. Это позволяет хранить код, который логически связан с внешним
 * классом, но требует доступа только к статическим членам внешнего класса.
 * <p>
 * Организация кода: Использование статических внутренних классов помогает организовать код, группируя классы, которые
 * имеют сильную логическую связь или используются только в контексте внешнего класса. Это упрощает чтение и понимание
 * кода.
 * <p>
 * Эффективность памяти: Поскольку статические внутренние классы не имеют ссылки на объект внешнего класса, они не
 * хранят лишнюю информацию и потребляют меньше памяти.
 * <p>
 * Статические члены класса – это переменные и методы, которые принадлежат самому классу, а не экземпляру (объекту)
 * класса. В Java статические члены класса объявляются с ключевым словом static. Они загружаются в память при первом
 * обращении к классу и существуют в единственном экземпляре для всего класса, а не для каждого объекта класса.
 * <p>
 * Статические члены класса включают:
 * <p>
 * Статические поля (переменные): Они представляют собой переменные, которые принадлежат самому классу, а не экземпляру
 * класса. Статические поля общие для всех объектов данного класса, и изменение статического поля одним объектом
 * отразится на всех остальных объектах этого класса.
 * <p>
 * Статические методы: Это методы, которые принадлежат классу, а не экземпляру класса. Статические методы могут быть
 * вызваны без создания объекта класса. Они имеют доступ только к статическим полям и методам класса, а не к
 * нестатическим, поскольку нестатические члены требуют наличия объекта для своего вызова.
 * <p>
 * Статические блоки инициализации: Это блоки кода, объявленные с ключевым словом static, которые выполняются при первом
 * обращении к классу. Они часто используются для инициализации статических полей класса.
 * <p>
 * Статические члены класса полезны для создания глобальных переменных и методов, которые не зависят от состояния
 * объекта и могут быть вызваны напрямую через имя класса. Однако статические члены следует использовать с
 * осторожностью,  * поскольку чрезмерное использование статических членов может привести к плохой модуляции и
 * затруднить тестирование кода.
 */

