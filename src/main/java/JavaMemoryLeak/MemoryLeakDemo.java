package JavaMemoryLeak;

import java.util.ArrayList;
import java.util.List;

/**
 * Утечка памяти происходит, когда объекты в памяти больше не нужны, но сборщик мусора не может их удалить из-за
 * наличия ссылок на них. В Java утечки памяти могут возникать по разным причинам, включая неправильное использование
 * коллекций, статических полей или слушателей событий.
 * <p>
 * Вот пример кода на Java, демонстрирующий утечку памяти:
 */

public class MemoryLeakDemo {
    private static class LeakingObject {
        private byte[] largeArray = new byte[1024 * 1024]; // 1Mbt
    }

    private static List<LeakingObject> leakingObjects = new ArrayList<>();

    public static void main(String[] args) throws InterruptedException {
        while (true) {
            leakingObjects.add(new LeakingObject());
            System.out.println("Leaking object count: " + leakingObjects.size());
            Thread.sleep(100); // Sleep for 0.1 second before creating the next object
        }
    }
}

/**
 * В этом примере мы создаем класс LeakingObject, который содержит массив байтов largeArray размером 1 МБ. В методе main
 * есть бесконечный цикл, который каждую секунду создает новый объект LeakingObject и добавляет его в список
 * leakingObjects. Поскольку список является статическим полем класса, ссылки на объекты LeakingObject не теряются,
 * и сборщик мусора не может их удалить. Это приводит к постоянному увеличению использования памяти, что в конечном
 * итоге может вызвать исключение OutOfMemoryError.
 *
 * Чтобы избежать утечки памяти, необходимо обеспечить правильное удаление ссылок на объекты, когда они больше не нужны,
 * и использовать слабые ссылки (WeakReference), если это возможно, для объектов, которые могут быть удалены сборщиком
 * мусора при необходимости.
 *
 * Статический внутренний класс (или статический вложенный класс) используется для создания логической связи между
 * внешним и внутренним классами, когда создание объекта внутреннего класса не зависит от создания объекта внешнего класса.
 *
 * Статический внутренний класс имеет следующие особенности и преимущества:
 *
 * Независимость от внешнего класса: Статический внутренний класс не имеет ссылки на объект внешнего класса, что делает
 * его более независимым. Объекты статического внутреннего класса могут быть созданы без создания объекта внешнего
 * класса.
 *
 * Улучшение инкапсуляции: Статический внутренний класс может иметь доступ к приватным статическим членам внешнего
 * класса, что обеспечивает улучшенную инкапсуляцию кода. Это позволяет хранить код, который логически связан с внешним
 * классом, но требует доступа только к статическим членам внешнего класса.
 *
 * Организация кода: Использование статических внутренних классов помогает организовать код, группируя классы, которые
 * имеют сильную логическую связь или используются только в контексте внешнего класса. Это упрощает чтение и понимание
 * кода.
 *
 * Эффективность памяти: Поскольку статические внутренние классы не имеют ссылки на объект внешнего класса, они не
 * хранят лишнюю информацию и потребляют меньше памяти.
 * */

